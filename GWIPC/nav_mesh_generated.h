// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NAVMESH_GWIPC_H_
#define FLATBUFFERS_GENERATED_NAVMESH_GWIPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 4,
             "Non-compatible flatbuffers version included");

#include "clientData_generated.h"

namespace GWIPC {

struct AdjacentTrapezoidIds;

struct NavMeshTrapezoid;
struct NavMeshTrapezoidBuilder;

struct NavMesh;
struct NavMeshBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AdjacentTrapezoidIds FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t left_id_;
  int32_t right_id_;
  int32_t down_id_;
  int32_t up_id_;

 public:
  AdjacentTrapezoidIds()
      : left_id_(0),
        right_id_(0),
        down_id_(0),
        up_id_(0) {
  }
  AdjacentTrapezoidIds(int32_t _left_id, int32_t _right_id, int32_t _down_id, int32_t _up_id)
      : left_id_(flatbuffers::EndianScalar(_left_id)),
        right_id_(flatbuffers::EndianScalar(_right_id)),
        down_id_(flatbuffers::EndianScalar(_down_id)),
        up_id_(flatbuffers::EndianScalar(_up_id)) {
  }
  int32_t left_id() const {
    return flatbuffers::EndianScalar(left_id_);
  }
  int32_t right_id() const {
    return flatbuffers::EndianScalar(right_id_);
  }
  int32_t down_id() const {
    return flatbuffers::EndianScalar(down_id_);
  }
  int32_t up_id() const {
    return flatbuffers::EndianScalar(up_id_);
  }
};
FLATBUFFERS_STRUCT_END(AdjacentTrapezoidIds, 16);

struct NavMeshTrapezoid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavMeshTrapezoidBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ADJACENT_TRAPEZOID_IDS = 6,
    VT_TOP_LEFT = 8,
    VT_TOP_RIGHT = 10,
    VT_BOTTOM_LEFT = 12,
    VT_BOTTOM_RIGHT = 14,
    VT_Z_PLANE = 16
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const GWIPC::AdjacentTrapezoidIds *adjacent_trapezoid_ids() const {
    return GetStruct<const GWIPC::AdjacentTrapezoidIds *>(VT_ADJACENT_TRAPEZOID_IDS);
  }
  const GWIPC::Vec3 *top_left() const {
    return GetStruct<const GWIPC::Vec3 *>(VT_TOP_LEFT);
  }
  const GWIPC::Vec3 *top_right() const {
    return GetStruct<const GWIPC::Vec3 *>(VT_TOP_RIGHT);
  }
  const GWIPC::Vec3 *bottom_left() const {
    return GetStruct<const GWIPC::Vec3 *>(VT_BOTTOM_LEFT);
  }
  const GWIPC::Vec3 *bottom_right() const {
    return GetStruct<const GWIPC::Vec3 *>(VT_BOTTOM_RIGHT);
  }
  uint32_t z_plane() const {
    return GetField<uint32_t>(VT_Z_PLANE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<GWIPC::AdjacentTrapezoidIds>(verifier, VT_ADJACENT_TRAPEZOID_IDS, 4) &&
           VerifyField<GWIPC::Vec3>(verifier, VT_TOP_LEFT, 4) &&
           VerifyField<GWIPC::Vec3>(verifier, VT_TOP_RIGHT, 4) &&
           VerifyField<GWIPC::Vec3>(verifier, VT_BOTTOM_LEFT, 4) &&
           VerifyField<GWIPC::Vec3>(verifier, VT_BOTTOM_RIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_Z_PLANE, 4) &&
           verifier.EndTable();
  }
};

struct NavMeshTrapezoidBuilder {
  typedef NavMeshTrapezoid Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(NavMeshTrapezoid::VT_ID, id, 0);
  }
  void add_adjacent_trapezoid_ids(const GWIPC::AdjacentTrapezoidIds *adjacent_trapezoid_ids) {
    fbb_.AddStruct(NavMeshTrapezoid::VT_ADJACENT_TRAPEZOID_IDS, adjacent_trapezoid_ids);
  }
  void add_top_left(const GWIPC::Vec3 *top_left) {
    fbb_.AddStruct(NavMeshTrapezoid::VT_TOP_LEFT, top_left);
  }
  void add_top_right(const GWIPC::Vec3 *top_right) {
    fbb_.AddStruct(NavMeshTrapezoid::VT_TOP_RIGHT, top_right);
  }
  void add_bottom_left(const GWIPC::Vec3 *bottom_left) {
    fbb_.AddStruct(NavMeshTrapezoid::VT_BOTTOM_LEFT, bottom_left);
  }
  void add_bottom_right(const GWIPC::Vec3 *bottom_right) {
    fbb_.AddStruct(NavMeshTrapezoid::VT_BOTTOM_RIGHT, bottom_right);
  }
  void add_z_plane(uint32_t z_plane) {
    fbb_.AddElement<uint32_t>(NavMeshTrapezoid::VT_Z_PLANE, z_plane, 0);
  }
  explicit NavMeshTrapezoidBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NavMeshTrapezoid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavMeshTrapezoid>(end);
    return o;
  }
};

inline flatbuffers::Offset<NavMeshTrapezoid> CreateNavMeshTrapezoid(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const GWIPC::AdjacentTrapezoidIds *adjacent_trapezoid_ids = nullptr,
    const GWIPC::Vec3 *top_left = nullptr,
    const GWIPC::Vec3 *top_right = nullptr,
    const GWIPC::Vec3 *bottom_left = nullptr,
    const GWIPC::Vec3 *bottom_right = nullptr,
    uint32_t z_plane = 0) {
  NavMeshTrapezoidBuilder builder_(_fbb);
  builder_.add_z_plane(z_plane);
  builder_.add_bottom_right(bottom_right);
  builder_.add_bottom_left(bottom_left);
  builder_.add_top_right(top_right);
  builder_.add_top_left(top_left);
  builder_.add_adjacent_trapezoid_ids(adjacent_trapezoid_ids);
  builder_.add_id(id);
  return builder_.Finish();
}

struct NavMesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavMeshBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRAPEZOIDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<GWIPC::NavMeshTrapezoid>> *trapezoids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GWIPC::NavMeshTrapezoid>> *>(VT_TRAPEZOIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRAPEZOIDS) &&
           verifier.VerifyVector(trapezoids()) &&
           verifier.VerifyVectorOfTables(trapezoids()) &&
           verifier.EndTable();
  }
};

struct NavMeshBuilder {
  typedef NavMesh Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trapezoids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::NavMeshTrapezoid>>> trapezoids) {
    fbb_.AddOffset(NavMesh::VT_TRAPEZOIDS, trapezoids);
  }
  explicit NavMeshBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NavMesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavMesh>(end);
    return o;
  }
};

inline flatbuffers::Offset<NavMesh> CreateNavMesh(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::NavMeshTrapezoid>>> trapezoids = 0) {
  NavMeshBuilder builder_(_fbb);
  builder_.add_trapezoids(trapezoids);
  return builder_.Finish();
}

inline flatbuffers::Offset<NavMesh> CreateNavMeshDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GWIPC::NavMeshTrapezoid>> *trapezoids = nullptr) {
  auto trapezoids__ = trapezoids ? _fbb.CreateVector<flatbuffers::Offset<GWIPC::NavMeshTrapezoid>>(*trapezoids) : 0;
  return GWIPC::CreateNavMesh(
      _fbb,
      trapezoids__);
}

inline const GWIPC::NavMesh *GetNavMesh(const void *buf) {
  return flatbuffers::GetRoot<GWIPC::NavMesh>(buf);
}

inline const GWIPC::NavMesh *GetSizePrefixedNavMesh(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<GWIPC::NavMesh>(buf);
}

inline bool VerifyNavMeshBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GWIPC::NavMesh>(nullptr);
}

inline bool VerifySizePrefixedNavMeshBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GWIPC::NavMesh>(nullptr);
}

inline void FinishNavMeshBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GWIPC::NavMesh> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNavMeshBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GWIPC::NavMesh> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace GWIPC

#endif  // FLATBUFFERS_GENERATED_NAVMESH_GWIPC_H_

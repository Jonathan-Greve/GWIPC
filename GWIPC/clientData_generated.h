// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CLIENTDATA_GWIPC_H_
#define FLATBUFFERS_GENERATED_CLIENTDATA_GWIPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace GWIPC {

struct Vec2;

struct Vec3;

struct Agent;

struct AgentLiving;
struct AgentLivingBuilder;

struct Skill;

struct Skillbar;
struct SkillbarBuilder;

struct Effect;

struct Buff;

struct Quest;
struct QuestBuilder;

struct Character;
struct CharacterBuilder;

struct Hero;
struct HeroBuilder;

struct MissionObjective;
struct MissionObjectiveBuilder;

struct Party;
struct PartyBuilder;

struct Instance;
struct InstanceBuilder;

struct ClientData;
struct ClientDataBuilder;

enum GameState : int8_t {
  GameState_Unknown = 0,
  GameState_Loading = 1,
  GameState_CharSelect = 2,
  GameState_InGame = 3,
  GameState_MIN = GameState_Unknown,
  GameState_MAX = GameState_InGame
};

inline const GameState (&EnumValuesGameState())[4] {
  static const GameState values[] = {
    GameState_Unknown,
    GameState_Loading,
    GameState_CharSelect,
    GameState_InGame
  };
  return values;
}

inline const char * const *EnumNamesGameState() {
  static const char * const names[5] = {
    "Unknown",
    "Loading",
    "CharSelect",
    "InGame",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameState(GameState e) {
  if (flatbuffers::IsOutRange(e, GameState_Unknown, GameState_InGame)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameState()[index];
}

enum TeamColor : int8_t {
  TeamColor_None = 0,
  TeamColor_Blue = 1,
  TeamColor_Red = 2,
  TeamColor_Yellow = 3,
  TeamColor_MIN = TeamColor_None,
  TeamColor_MAX = TeamColor_Yellow
};

inline const TeamColor (&EnumValuesTeamColor())[4] {
  static const TeamColor values[] = {
    TeamColor_None,
    TeamColor_Blue,
    TeamColor_Red,
    TeamColor_Yellow
  };
  return values;
}

inline const char * const *EnumNamesTeamColor() {
  static const char * const names[5] = {
    "None",
    "Blue",
    "Red",
    "Yellow",
    nullptr
  };
  return names;
}

inline const char *EnumNameTeamColor(TeamColor e) {
  if (flatbuffers::IsOutRange(e, TeamColor_None, TeamColor_Yellow)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTeamColor()[index];
}

enum Profession : int8_t {
  Profession_None = 0,
  Profession_Warrior = 1,
  Profession_Ranger = 2,
  Profession_Monk = 3,
  Profession_Necromancer = 4,
  Profession_Mesmer = 5,
  Profession_Elementalist = 6,
  Profession_Assassin = 7,
  Profession_Ritualist = 8,
  Profession_Paragon = 9,
  Profession_Dervish = 10,
  Profession_MIN = Profession_None,
  Profession_MAX = Profession_Dervish
};

inline const Profession (&EnumValuesProfession())[11] {
  static const Profession values[] = {
    Profession_None,
    Profession_Warrior,
    Profession_Ranger,
    Profession_Monk,
    Profession_Necromancer,
    Profession_Mesmer,
    Profession_Elementalist,
    Profession_Assassin,
    Profession_Ritualist,
    Profession_Paragon,
    Profession_Dervish
  };
  return values;
}

inline const char * const *EnumNamesProfession() {
  static const char * const names[12] = {
    "None",
    "Warrior",
    "Ranger",
    "Monk",
    "Necromancer",
    "Mesmer",
    "Elementalist",
    "Assassin",
    "Ritualist",
    "Paragon",
    "Dervish",
    nullptr
  };
  return names;
}

inline const char *EnumNameProfession(Profession e) {
  if (flatbuffers::IsOutRange(e, Profession_None, Profession_Dervish)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProfession()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Agent FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t agent_id_;
  GWIPC::Vec3 position_;
  GWIPC::Vec3 terrain_normal_;
  float rotation_;
  GWIPC::Vec2 velocity_;
  float model_width_;
  float model_height_;
  uint32_t instance_timer_;

 public:
  Agent()
      : agent_id_(0),
        position_(),
        terrain_normal_(),
        rotation_(0),
        velocity_(),
        model_width_(0),
        model_height_(0),
        instance_timer_(0) {
  }
  Agent(uint32_t _agent_id, const GWIPC::Vec3 &_position, const GWIPC::Vec3 &_terrain_normal, float _rotation, const GWIPC::Vec2 &_velocity, float _model_width, float _model_height, uint32_t _instance_timer)
      : agent_id_(flatbuffers::EndianScalar(_agent_id)),
        position_(_position),
        terrain_normal_(_terrain_normal),
        rotation_(flatbuffers::EndianScalar(_rotation)),
        velocity_(_velocity),
        model_width_(flatbuffers::EndianScalar(_model_width)),
        model_height_(flatbuffers::EndianScalar(_model_height)),
        instance_timer_(flatbuffers::EndianScalar(_instance_timer)) {
  }
  uint32_t agent_id() const {
    return flatbuffers::EndianScalar(agent_id_);
  }
  const GWIPC::Vec3 &position() const {
    return position_;
  }
  const GWIPC::Vec3 &terrain_normal() const {
    return terrain_normal_;
  }
  float rotation() const {
    return flatbuffers::EndianScalar(rotation_);
  }
  const GWIPC::Vec2 &velocity() const {
    return velocity_;
  }
  float model_width() const {
    return flatbuffers::EndianScalar(model_width_);
  }
  float model_height() const {
    return flatbuffers::EndianScalar(model_height_);
  }
  uint32_t instance_timer() const {
    return flatbuffers::EndianScalar(instance_timer_);
  }
};
FLATBUFFERS_STRUCT_END(Agent, 52);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Skill FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t skill_id_;
  uint16_t recharge_ms_;
  uint8_t adrenaline_;
  int8_t padding0__;

 public:
  Skill()
      : skill_id_(0),
        recharge_ms_(0),
        adrenaline_(0),
        padding0__(0) {
    (void)padding0__;
  }
  Skill(uint16_t _skill_id, uint16_t _recharge_ms, uint8_t _adrenaline)
      : skill_id_(flatbuffers::EndianScalar(_skill_id)),
        recharge_ms_(flatbuffers::EndianScalar(_recharge_ms)),
        adrenaline_(flatbuffers::EndianScalar(_adrenaline)),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t skill_id() const {
    return flatbuffers::EndianScalar(skill_id_);
  }
  uint16_t recharge_ms() const {
    return flatbuffers::EndianScalar(recharge_ms_);
  }
  uint8_t adrenaline() const {
    return flatbuffers::EndianScalar(adrenaline_);
  }
};
FLATBUFFERS_STRUCT_END(Skill, 6);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Effect FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t skill_id_;
  uint32_t source_agent_id_;
  float duration_;

 public:
  Effect()
      : skill_id_(0),
        source_agent_id_(0),
        duration_(0) {
  }
  Effect(uint32_t _skill_id, uint32_t _source_agent_id, float _duration)
      : skill_id_(flatbuffers::EndianScalar(_skill_id)),
        source_agent_id_(flatbuffers::EndianScalar(_source_agent_id)),
        duration_(flatbuffers::EndianScalar(_duration)) {
  }
  uint32_t skill_id() const {
    return flatbuffers::EndianScalar(skill_id_);
  }
  uint32_t source_agent_id() const {
    return flatbuffers::EndianScalar(source_agent_id_);
  }
  float duration() const {
    return flatbuffers::EndianScalar(duration_);
  }
};
FLATBUFFERS_STRUCT_END(Effect, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Buff FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t skill_id_;
  uint32_t target_agent_id_;
  uint32_t buff_id_;

 public:
  Buff()
      : skill_id_(0),
        target_agent_id_(0),
        buff_id_(0) {
  }
  Buff(uint32_t _skill_id, uint32_t _target_agent_id, uint32_t _buff_id)
      : skill_id_(flatbuffers::EndianScalar(_skill_id)),
        target_agent_id_(flatbuffers::EndianScalar(_target_agent_id)),
        buff_id_(flatbuffers::EndianScalar(_buff_id)) {
  }
  uint32_t skill_id() const {
    return flatbuffers::EndianScalar(skill_id_);
  }
  uint32_t target_agent_id() const {
    return flatbuffers::EndianScalar(target_agent_id_);
  }
  uint32_t buff_id() const {
    return flatbuffers::EndianScalar(buff_id_);
  }
};
FLATBUFFERS_STRUCT_END(Buff, 12);

struct AgentLiving FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AgentLivingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AGENT = 4,
    VT_NAME = 6,
    VT_OWNER_AGENT_ID = 8,
    VT_ANIMATION_TYPE = 10,
    VT_WEAPON_ATTACK_SPEED = 12,
    VT_WEAPON_ATTACK_SPEED_MODIFIER = 14,
    VT_PLAYER_NUMBER = 16,
    VT_PRIMARY_PROFESSION = 18,
    VT_SECONDARY_PROFESSION = 20,
    VT_TEAM_COLOR = 22,
    VT_GUILD_ID = 24,
    VT_LEVEL = 26,
    VT_HEALTH = 28,
    VT_MAX_HEALTH = 30,
    VT_HEALTH_RECHARGE = 32,
    VT_ENERGY = 34,
    VT_MAX_ENERGY = 36,
    VT_ENERGY_RECHARGE = 38,
    VT_PARTY_SLOT = 40
  };
  const GWIPC::Agent *agent() const {
    return GetStruct<const GWIPC::Agent *>(VT_AGENT);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t owner_agent_id() const {
    return GetField<uint32_t>(VT_OWNER_AGENT_ID, 0);
  }
  float animation_type() const {
    return GetField<float>(VT_ANIMATION_TYPE, 0.0f);
  }
  float weapon_attack_speed() const {
    return GetField<float>(VT_WEAPON_ATTACK_SPEED, 0.0f);
  }
  float weapon_attack_speed_modifier() const {
    return GetField<float>(VT_WEAPON_ATTACK_SPEED_MODIFIER, 0.0f);
  }
  uint16_t player_number() const {
    return GetField<uint16_t>(VT_PLAYER_NUMBER, 0);
  }
  GWIPC::Profession primary_profession() const {
    return static_cast<GWIPC::Profession>(GetField<int8_t>(VT_PRIMARY_PROFESSION, 0));
  }
  GWIPC::Profession secondary_profession() const {
    return static_cast<GWIPC::Profession>(GetField<int8_t>(VT_SECONDARY_PROFESSION, 0));
  }
  GWIPC::TeamColor team_color() const {
    return static_cast<GWIPC::TeamColor>(GetField<int8_t>(VT_TEAM_COLOR, 0));
  }
  uint16_t guild_id() const {
    return GetField<uint16_t>(VT_GUILD_ID, 0);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  float health() const {
    return GetField<float>(VT_HEALTH, 0.0f);
  }
  uint32_t max_health() const {
    return GetField<uint32_t>(VT_MAX_HEALTH, 0);
  }
  float health_recharge() const {
    return GetField<float>(VT_HEALTH_RECHARGE, 0.0f);
  }
  float energy() const {
    return GetField<float>(VT_ENERGY, 0.0f);
  }
  uint32_t max_energy() const {
    return GetField<uint32_t>(VT_MAX_ENERGY, 0);
  }
  float energy_recharge() const {
    return GetField<float>(VT_ENERGY_RECHARGE, 0.0f);
  }
  uint8_t party_slot() const {
    return GetField<uint8_t>(VT_PARTY_SLOT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<GWIPC::Agent>(verifier, VT_AGENT, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OWNER_AGENT_ID, 4) &&
           VerifyField<float>(verifier, VT_ANIMATION_TYPE, 4) &&
           VerifyField<float>(verifier, VT_WEAPON_ATTACK_SPEED, 4) &&
           VerifyField<float>(verifier, VT_WEAPON_ATTACK_SPEED_MODIFIER, 4) &&
           VerifyField<uint16_t>(verifier, VT_PLAYER_NUMBER, 2) &&
           VerifyField<int8_t>(verifier, VT_PRIMARY_PROFESSION, 1) &&
           VerifyField<int8_t>(verifier, VT_SECONDARY_PROFESSION, 1) &&
           VerifyField<int8_t>(verifier, VT_TEAM_COLOR, 1) &&
           VerifyField<uint16_t>(verifier, VT_GUILD_ID, 2) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL, 1) &&
           VerifyField<float>(verifier, VT_HEALTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAX_HEALTH, 4) &&
           VerifyField<float>(verifier, VT_HEALTH_RECHARGE, 4) &&
           VerifyField<float>(verifier, VT_ENERGY, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAX_ENERGY, 4) &&
           VerifyField<float>(verifier, VT_ENERGY_RECHARGE, 4) &&
           VerifyField<uint8_t>(verifier, VT_PARTY_SLOT, 1) &&
           verifier.EndTable();
  }
};

struct AgentLivingBuilder {
  typedef AgentLiving Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_agent(const GWIPC::Agent *agent) {
    fbb_.AddStruct(AgentLiving::VT_AGENT, agent);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AgentLiving::VT_NAME, name);
  }
  void add_owner_agent_id(uint32_t owner_agent_id) {
    fbb_.AddElement<uint32_t>(AgentLiving::VT_OWNER_AGENT_ID, owner_agent_id, 0);
  }
  void add_animation_type(float animation_type) {
    fbb_.AddElement<float>(AgentLiving::VT_ANIMATION_TYPE, animation_type, 0.0f);
  }
  void add_weapon_attack_speed(float weapon_attack_speed) {
    fbb_.AddElement<float>(AgentLiving::VT_WEAPON_ATTACK_SPEED, weapon_attack_speed, 0.0f);
  }
  void add_weapon_attack_speed_modifier(float weapon_attack_speed_modifier) {
    fbb_.AddElement<float>(AgentLiving::VT_WEAPON_ATTACK_SPEED_MODIFIER, weapon_attack_speed_modifier, 0.0f);
  }
  void add_player_number(uint16_t player_number) {
    fbb_.AddElement<uint16_t>(AgentLiving::VT_PLAYER_NUMBER, player_number, 0);
  }
  void add_primary_profession(GWIPC::Profession primary_profession) {
    fbb_.AddElement<int8_t>(AgentLiving::VT_PRIMARY_PROFESSION, static_cast<int8_t>(primary_profession), 0);
  }
  void add_secondary_profession(GWIPC::Profession secondary_profession) {
    fbb_.AddElement<int8_t>(AgentLiving::VT_SECONDARY_PROFESSION, static_cast<int8_t>(secondary_profession), 0);
  }
  void add_team_color(GWIPC::TeamColor team_color) {
    fbb_.AddElement<int8_t>(AgentLiving::VT_TEAM_COLOR, static_cast<int8_t>(team_color), 0);
  }
  void add_guild_id(uint16_t guild_id) {
    fbb_.AddElement<uint16_t>(AgentLiving::VT_GUILD_ID, guild_id, 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(AgentLiving::VT_LEVEL, level, 0);
  }
  void add_health(float health) {
    fbb_.AddElement<float>(AgentLiving::VT_HEALTH, health, 0.0f);
  }
  void add_max_health(uint32_t max_health) {
    fbb_.AddElement<uint32_t>(AgentLiving::VT_MAX_HEALTH, max_health, 0);
  }
  void add_health_recharge(float health_recharge) {
    fbb_.AddElement<float>(AgentLiving::VT_HEALTH_RECHARGE, health_recharge, 0.0f);
  }
  void add_energy(float energy) {
    fbb_.AddElement<float>(AgentLiving::VT_ENERGY, energy, 0.0f);
  }
  void add_max_energy(uint32_t max_energy) {
    fbb_.AddElement<uint32_t>(AgentLiving::VT_MAX_ENERGY, max_energy, 0);
  }
  void add_energy_recharge(float energy_recharge) {
    fbb_.AddElement<float>(AgentLiving::VT_ENERGY_RECHARGE, energy_recharge, 0.0f);
  }
  void add_party_slot(uint8_t party_slot) {
    fbb_.AddElement<uint8_t>(AgentLiving::VT_PARTY_SLOT, party_slot, 0);
  }
  explicit AgentLivingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AgentLiving> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AgentLiving>(end);
    return o;
  }
};

inline flatbuffers::Offset<AgentLiving> CreateAgentLiving(
    flatbuffers::FlatBufferBuilder &_fbb,
    const GWIPC::Agent *agent = nullptr,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t owner_agent_id = 0,
    float animation_type = 0.0f,
    float weapon_attack_speed = 0.0f,
    float weapon_attack_speed_modifier = 0.0f,
    uint16_t player_number = 0,
    GWIPC::Profession primary_profession = GWIPC::Profession_None,
    GWIPC::Profession secondary_profession = GWIPC::Profession_None,
    GWIPC::TeamColor team_color = GWIPC::TeamColor_None,
    uint16_t guild_id = 0,
    uint8_t level = 0,
    float health = 0.0f,
    uint32_t max_health = 0,
    float health_recharge = 0.0f,
    float energy = 0.0f,
    uint32_t max_energy = 0,
    float energy_recharge = 0.0f,
    uint8_t party_slot = 0) {
  AgentLivingBuilder builder_(_fbb);
  builder_.add_energy_recharge(energy_recharge);
  builder_.add_max_energy(max_energy);
  builder_.add_energy(energy);
  builder_.add_health_recharge(health_recharge);
  builder_.add_max_health(max_health);
  builder_.add_health(health);
  builder_.add_weapon_attack_speed_modifier(weapon_attack_speed_modifier);
  builder_.add_weapon_attack_speed(weapon_attack_speed);
  builder_.add_animation_type(animation_type);
  builder_.add_owner_agent_id(owner_agent_id);
  builder_.add_name(name);
  builder_.add_agent(agent);
  builder_.add_guild_id(guild_id);
  builder_.add_player_number(player_number);
  builder_.add_party_slot(party_slot);
  builder_.add_level(level);
  builder_.add_team_color(team_color);
  builder_.add_secondary_profession(secondary_profession);
  builder_.add_primary_profession(primary_profession);
  return builder_.Finish();
}

inline flatbuffers::Offset<AgentLiving> CreateAgentLivingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const GWIPC::Agent *agent = nullptr,
    const char *name = nullptr,
    uint32_t owner_agent_id = 0,
    float animation_type = 0.0f,
    float weapon_attack_speed = 0.0f,
    float weapon_attack_speed_modifier = 0.0f,
    uint16_t player_number = 0,
    GWIPC::Profession primary_profession = GWIPC::Profession_None,
    GWIPC::Profession secondary_profession = GWIPC::Profession_None,
    GWIPC::TeamColor team_color = GWIPC::TeamColor_None,
    uint16_t guild_id = 0,
    uint8_t level = 0,
    float health = 0.0f,
    uint32_t max_health = 0,
    float health_recharge = 0.0f,
    float energy = 0.0f,
    uint32_t max_energy = 0,
    float energy_recharge = 0.0f,
    uint8_t party_slot = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return GWIPC::CreateAgentLiving(
      _fbb,
      agent,
      name__,
      owner_agent_id,
      animation_type,
      weapon_attack_speed,
      weapon_attack_speed_modifier,
      player_number,
      primary_profession,
      secondary_profession,
      team_color,
      guild_id,
      level,
      health,
      max_health,
      health_recharge,
      energy,
      max_energy,
      energy_recharge,
      party_slot);
}

struct Skillbar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkillbarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKILLS = 4
  };
  const flatbuffers::Vector<const GWIPC::Skill *> *skills() const {
    return GetPointer<const flatbuffers::Vector<const GWIPC::Skill *> *>(VT_SKILLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKILLS) &&
           verifier.VerifyVector(skills()) &&
           verifier.EndTable();
  }
};

struct SkillbarBuilder {
  typedef Skillbar Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skills(flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Skill *>> skills) {
    fbb_.AddOffset(Skillbar::VT_SKILLS, skills);
  }
  explicit SkillbarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Skillbar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Skillbar>(end);
    return o;
  }
};

inline flatbuffers::Offset<Skillbar> CreateSkillbar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Skill *>> skills = 0) {
  SkillbarBuilder builder_(_fbb);
  builder_.add_skills(skills);
  return builder_.Finish();
}

inline flatbuffers::Offset<Skillbar> CreateSkillbarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<GWIPC::Skill> *skills = nullptr) {
  auto skills__ = skills ? _fbb.CreateVectorOfStructs<GWIPC::Skill>(*skills) : 0;
  return GWIPC::CreateSkillbar(
      _fbb,
      skills__);
}

struct Quest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUEST_ID = 4,
    VT_LOG_STATE = 6,
    VT_LOCATION = 8,
    VT_NAME = 10,
    VT_NPC_NAME = 12,
    VT_MAP_FROM = 14,
    VT_MAP_TO = 16,
    VT_MARKER = 18,
    VT_DESCRIPTION = 20,
    VT_OBJECTIVES = 22
  };
  uint32_t quest_id() const {
    return GetField<uint32_t>(VT_QUEST_ID, 0);
  }
  uint32_t log_state() const {
    return GetField<uint32_t>(VT_LOG_STATE, 0);
  }
  const flatbuffers::String *location() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCATION);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *npc_name() const {
    return GetPointer<const flatbuffers::String *>(VT_NPC_NAME);
  }
  uint32_t map_from() const {
    return GetField<uint32_t>(VT_MAP_FROM, 0);
  }
  uint32_t map_to() const {
    return GetField<uint32_t>(VT_MAP_TO, 0);
  }
  const GWIPC::Vec3 *marker() const {
    return GetStruct<const GWIPC::Vec3 *>(VT_MARKER);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::String *objectives() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECTIVES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_QUEST_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_LOG_STATE, 4) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyString(location()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_NPC_NAME) &&
           verifier.VerifyString(npc_name()) &&
           VerifyField<uint32_t>(verifier, VT_MAP_FROM, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAP_TO, 4) &&
           VerifyField<GWIPC::Vec3>(verifier, VT_MARKER, 4) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_OBJECTIVES) &&
           verifier.VerifyString(objectives()) &&
           verifier.EndTable();
  }
};

struct QuestBuilder {
  typedef Quest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_quest_id(uint32_t quest_id) {
    fbb_.AddElement<uint32_t>(Quest::VT_QUEST_ID, quest_id, 0);
  }
  void add_log_state(uint32_t log_state) {
    fbb_.AddElement<uint32_t>(Quest::VT_LOG_STATE, log_state, 0);
  }
  void add_location(flatbuffers::Offset<flatbuffers::String> location) {
    fbb_.AddOffset(Quest::VT_LOCATION, location);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Quest::VT_NAME, name);
  }
  void add_npc_name(flatbuffers::Offset<flatbuffers::String> npc_name) {
    fbb_.AddOffset(Quest::VT_NPC_NAME, npc_name);
  }
  void add_map_from(uint32_t map_from) {
    fbb_.AddElement<uint32_t>(Quest::VT_MAP_FROM, map_from, 0);
  }
  void add_map_to(uint32_t map_to) {
    fbb_.AddElement<uint32_t>(Quest::VT_MAP_TO, map_to, 0);
  }
  void add_marker(const GWIPC::Vec3 *marker) {
    fbb_.AddStruct(Quest::VT_MARKER, marker);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Quest::VT_DESCRIPTION, description);
  }
  void add_objectives(flatbuffers::Offset<flatbuffers::String> objectives) {
    fbb_.AddOffset(Quest::VT_OBJECTIVES, objectives);
  }
  explicit QuestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Quest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quest>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quest> CreateQuest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t quest_id = 0,
    uint32_t log_state = 0,
    flatbuffers::Offset<flatbuffers::String> location = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> npc_name = 0,
    uint32_t map_from = 0,
    uint32_t map_to = 0,
    const GWIPC::Vec3 *marker = nullptr,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::String> objectives = 0) {
  QuestBuilder builder_(_fbb);
  builder_.add_objectives(objectives);
  builder_.add_description(description);
  builder_.add_marker(marker);
  builder_.add_map_to(map_to);
  builder_.add_map_from(map_from);
  builder_.add_npc_name(npc_name);
  builder_.add_name(name);
  builder_.add_location(location);
  builder_.add_log_state(log_state);
  builder_.add_quest_id(quest_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Quest> CreateQuestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t quest_id = 0,
    uint32_t log_state = 0,
    const char *location = nullptr,
    const char *name = nullptr,
    const char *npc_name = nullptr,
    uint32_t map_from = 0,
    uint32_t map_to = 0,
    const GWIPC::Vec3 *marker = nullptr,
    const char *description = nullptr,
    const char *objectives = nullptr) {
  auto location__ = location ? _fbb.CreateString(location) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto npc_name__ = npc_name ? _fbb.CreateString(npc_name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto objectives__ = objectives ? _fbb.CreateString(objectives) : 0;
  return GWIPC::CreateQuest(
      _fbb,
      quest_id,
      log_state,
      location__,
      name__,
      npc_name__,
      map_from,
      map_to,
      marker,
      description__,
      objectives__);
}

struct Character FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CharacterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AGENT_LIVING = 4,
    VT_SKILLBAR = 6,
    VT_EFFECTS = 8,
    VT_BUFFS = 10
  };
  const GWIPC::AgentLiving *agent_living() const {
    return GetPointer<const GWIPC::AgentLiving *>(VT_AGENT_LIVING);
  }
  const GWIPC::Skillbar *skillbar() const {
    return GetPointer<const GWIPC::Skillbar *>(VT_SKILLBAR);
  }
  const flatbuffers::Vector<const GWIPC::Effect *> *effects() const {
    return GetPointer<const flatbuffers::Vector<const GWIPC::Effect *> *>(VT_EFFECTS);
  }
  const flatbuffers::Vector<const GWIPC::Buff *> *buffs() const {
    return GetPointer<const flatbuffers::Vector<const GWIPC::Buff *> *>(VT_BUFFS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AGENT_LIVING) &&
           verifier.VerifyTable(agent_living()) &&
           VerifyOffset(verifier, VT_SKILLBAR) &&
           verifier.VerifyTable(skillbar()) &&
           VerifyOffset(verifier, VT_EFFECTS) &&
           verifier.VerifyVector(effects()) &&
           VerifyOffset(verifier, VT_BUFFS) &&
           verifier.VerifyVector(buffs()) &&
           verifier.EndTable();
  }
};

struct CharacterBuilder {
  typedef Character Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_agent_living(flatbuffers::Offset<GWIPC::AgentLiving> agent_living) {
    fbb_.AddOffset(Character::VT_AGENT_LIVING, agent_living);
  }
  void add_skillbar(flatbuffers::Offset<GWIPC::Skillbar> skillbar) {
    fbb_.AddOffset(Character::VT_SKILLBAR, skillbar);
  }
  void add_effects(flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Effect *>> effects) {
    fbb_.AddOffset(Character::VT_EFFECTS, effects);
  }
  void add_buffs(flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Buff *>> buffs) {
    fbb_.AddOffset(Character::VT_BUFFS, buffs);
  }
  explicit CharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Character> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Character>(end);
    return o;
  }
};

inline flatbuffers::Offset<Character> CreateCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GWIPC::AgentLiving> agent_living = 0,
    flatbuffers::Offset<GWIPC::Skillbar> skillbar = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Effect *>> effects = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Buff *>> buffs = 0) {
  CharacterBuilder builder_(_fbb);
  builder_.add_buffs(buffs);
  builder_.add_effects(effects);
  builder_.add_skillbar(skillbar);
  builder_.add_agent_living(agent_living);
  return builder_.Finish();
}

inline flatbuffers::Offset<Character> CreateCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GWIPC::AgentLiving> agent_living = 0,
    flatbuffers::Offset<GWIPC::Skillbar> skillbar = 0,
    const std::vector<GWIPC::Effect> *effects = nullptr,
    const std::vector<GWIPC::Buff> *buffs = nullptr) {
  auto effects__ = effects ? _fbb.CreateVectorOfStructs<GWIPC::Effect>(*effects) : 0;
  auto buffs__ = buffs ? _fbb.CreateVectorOfStructs<GWIPC::Buff>(*buffs) : 0;
  return GWIPC::CreateCharacter(
      _fbb,
      agent_living,
      skillbar,
      effects__,
      buffs__);
}

struct Hero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeroBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AGENT_LIVING = 4,
    VT_SKILLBAR = 6,
    VT_EFFECTS = 8,
    VT_BUFFS = 10,
    VT_FLAG_POSITION = 12,
    VT_HERO_ID = 14,
    VT_OWNER_PLAYER_ID = 16
  };
  const GWIPC::AgentLiving *agent_living() const {
    return GetPointer<const GWIPC::AgentLiving *>(VT_AGENT_LIVING);
  }
  const GWIPC::Skillbar *skillbar() const {
    return GetPointer<const GWIPC::Skillbar *>(VT_SKILLBAR);
  }
  const flatbuffers::Vector<const GWIPC::Effect *> *effects() const {
    return GetPointer<const flatbuffers::Vector<const GWIPC::Effect *> *>(VT_EFFECTS);
  }
  const flatbuffers::Vector<const GWIPC::Buff *> *buffs() const {
    return GetPointer<const flatbuffers::Vector<const GWIPC::Buff *> *>(VT_BUFFS);
  }
  const GWIPC::Vec2 *flag_position() const {
    return GetStruct<const GWIPC::Vec2 *>(VT_FLAG_POSITION);
  }
  uint32_t hero_id() const {
    return GetField<uint32_t>(VT_HERO_ID, 0);
  }
  uint32_t owner_player_id() const {
    return GetField<uint32_t>(VT_OWNER_PLAYER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AGENT_LIVING) &&
           verifier.VerifyTable(agent_living()) &&
           VerifyOffset(verifier, VT_SKILLBAR) &&
           verifier.VerifyTable(skillbar()) &&
           VerifyOffset(verifier, VT_EFFECTS) &&
           verifier.VerifyVector(effects()) &&
           VerifyOffset(verifier, VT_BUFFS) &&
           verifier.VerifyVector(buffs()) &&
           VerifyField<GWIPC::Vec2>(verifier, VT_FLAG_POSITION, 4) &&
           VerifyField<uint32_t>(verifier, VT_HERO_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_OWNER_PLAYER_ID, 4) &&
           verifier.EndTable();
  }
};

struct HeroBuilder {
  typedef Hero Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_agent_living(flatbuffers::Offset<GWIPC::AgentLiving> agent_living) {
    fbb_.AddOffset(Hero::VT_AGENT_LIVING, agent_living);
  }
  void add_skillbar(flatbuffers::Offset<GWIPC::Skillbar> skillbar) {
    fbb_.AddOffset(Hero::VT_SKILLBAR, skillbar);
  }
  void add_effects(flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Effect *>> effects) {
    fbb_.AddOffset(Hero::VT_EFFECTS, effects);
  }
  void add_buffs(flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Buff *>> buffs) {
    fbb_.AddOffset(Hero::VT_BUFFS, buffs);
  }
  void add_flag_position(const GWIPC::Vec2 *flag_position) {
    fbb_.AddStruct(Hero::VT_FLAG_POSITION, flag_position);
  }
  void add_hero_id(uint32_t hero_id) {
    fbb_.AddElement<uint32_t>(Hero::VT_HERO_ID, hero_id, 0);
  }
  void add_owner_player_id(uint32_t owner_player_id) {
    fbb_.AddElement<uint32_t>(Hero::VT_OWNER_PLAYER_ID, owner_player_id, 0);
  }
  explicit HeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Hero> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Hero>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hero> CreateHero(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GWIPC::AgentLiving> agent_living = 0,
    flatbuffers::Offset<GWIPC::Skillbar> skillbar = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Effect *>> effects = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GWIPC::Buff *>> buffs = 0,
    const GWIPC::Vec2 *flag_position = nullptr,
    uint32_t hero_id = 0,
    uint32_t owner_player_id = 0) {
  HeroBuilder builder_(_fbb);
  builder_.add_owner_player_id(owner_player_id);
  builder_.add_hero_id(hero_id);
  builder_.add_flag_position(flag_position);
  builder_.add_buffs(buffs);
  builder_.add_effects(effects);
  builder_.add_skillbar(skillbar);
  builder_.add_agent_living(agent_living);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hero> CreateHeroDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GWIPC::AgentLiving> agent_living = 0,
    flatbuffers::Offset<GWIPC::Skillbar> skillbar = 0,
    const std::vector<GWIPC::Effect> *effects = nullptr,
    const std::vector<GWIPC::Buff> *buffs = nullptr,
    const GWIPC::Vec2 *flag_position = nullptr,
    uint32_t hero_id = 0,
    uint32_t owner_player_id = 0) {
  auto effects__ = effects ? _fbb.CreateVectorOfStructs<GWIPC::Effect>(*effects) : 0;
  auto buffs__ = buffs ? _fbb.CreateVectorOfStructs<GWIPC::Buff>(*buffs) : 0;
  return GWIPC::CreateHero(
      _fbb,
      agent_living,
      skillbar,
      effects__,
      buffs__,
      flag_position,
      hero_id,
      owner_player_id);
}

struct MissionObjective FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MissionObjectiveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTIVE_ID = 4,
    VT_DESCRIPTION = 6,
    VT_TYPE = 8
  };
  uint32_t objective_id() const {
    return GetField<uint32_t>(VT_OBJECTIVE_ID, 0);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  uint32_t type() const {
    return GetField<uint32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OBJECTIVE_ID, 4) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<uint32_t>(verifier, VT_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct MissionObjectiveBuilder {
  typedef MissionObjective Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objective_id(uint32_t objective_id) {
    fbb_.AddElement<uint32_t>(MissionObjective::VT_OBJECTIVE_ID, objective_id, 0);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(MissionObjective::VT_DESCRIPTION, description);
  }
  void add_type(uint32_t type) {
    fbb_.AddElement<uint32_t>(MissionObjective::VT_TYPE, type, 0);
  }
  explicit MissionObjectiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MissionObjective> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MissionObjective>(end);
    return o;
  }
};

inline flatbuffers::Offset<MissionObjective> CreateMissionObjective(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t objective_id = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    uint32_t type = 0) {
  MissionObjectiveBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_description(description);
  builder_.add_objective_id(objective_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MissionObjective> CreateMissionObjectiveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t objective_id = 0,
    const char *description = nullptr,
    uint32_t type = 0) {
  auto description__ = description ? _fbb.CreateString(description) : 0;
  return GWIPC::CreateMissionObjective(
      _fbb,
      objective_id,
      description__,
      type);
}

struct Party FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTY_ID = 4,
    VT_PLAYER_MEMBERS = 6,
    VT_HERO_MEMBERS = 8,
    VT_HENCHMAN_MEMBERS = 10,
    VT_FLAG_ALL_POSITION = 12,
    VT_MISSION_OBJECTIVES = 14
  };
  uint32_t party_id() const {
    return GetField<uint32_t>(VT_PARTY_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GWIPC::AgentLiving>> *player_members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GWIPC::AgentLiving>> *>(VT_PLAYER_MEMBERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GWIPC::Hero>> *hero_members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GWIPC::Hero>> *>(VT_HERO_MEMBERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GWIPC::AgentLiving>> *henchman_members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GWIPC::AgentLiving>> *>(VT_HENCHMAN_MEMBERS);
  }
  const GWIPC::Vec3 *flag_all_position() const {
    return GetStruct<const GWIPC::Vec3 *>(VT_FLAG_ALL_POSITION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GWIPC::MissionObjective>> *mission_objectives() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GWIPC::MissionObjective>> *>(VT_MISSION_OBJECTIVES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PARTY_ID, 4) &&
           VerifyOffset(verifier, VT_PLAYER_MEMBERS) &&
           verifier.VerifyVector(player_members()) &&
           verifier.VerifyVectorOfTables(player_members()) &&
           VerifyOffset(verifier, VT_HERO_MEMBERS) &&
           verifier.VerifyVector(hero_members()) &&
           verifier.VerifyVectorOfTables(hero_members()) &&
           VerifyOffset(verifier, VT_HENCHMAN_MEMBERS) &&
           verifier.VerifyVector(henchman_members()) &&
           verifier.VerifyVectorOfTables(henchman_members()) &&
           VerifyField<GWIPC::Vec3>(verifier, VT_FLAG_ALL_POSITION, 4) &&
           VerifyOffset(verifier, VT_MISSION_OBJECTIVES) &&
           verifier.VerifyVector(mission_objectives()) &&
           verifier.VerifyVectorOfTables(mission_objectives()) &&
           verifier.EndTable();
  }
};

struct PartyBuilder {
  typedef Party Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_party_id(uint32_t party_id) {
    fbb_.AddElement<uint32_t>(Party::VT_PARTY_ID, party_id, 0);
  }
  void add_player_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::AgentLiving>>> player_members) {
    fbb_.AddOffset(Party::VT_PLAYER_MEMBERS, player_members);
  }
  void add_hero_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::Hero>>> hero_members) {
    fbb_.AddOffset(Party::VT_HERO_MEMBERS, hero_members);
  }
  void add_henchman_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::AgentLiving>>> henchman_members) {
    fbb_.AddOffset(Party::VT_HENCHMAN_MEMBERS, henchman_members);
  }
  void add_flag_all_position(const GWIPC::Vec3 *flag_all_position) {
    fbb_.AddStruct(Party::VT_FLAG_ALL_POSITION, flag_all_position);
  }
  void add_mission_objectives(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::MissionObjective>>> mission_objectives) {
    fbb_.AddOffset(Party::VT_MISSION_OBJECTIVES, mission_objectives);
  }
  explicit PartyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Party> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Party>(end);
    return o;
  }
};

inline flatbuffers::Offset<Party> CreateParty(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t party_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::AgentLiving>>> player_members = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::Hero>>> hero_members = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::AgentLiving>>> henchman_members = 0,
    const GWIPC::Vec3 *flag_all_position = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GWIPC::MissionObjective>>> mission_objectives = 0) {
  PartyBuilder builder_(_fbb);
  builder_.add_mission_objectives(mission_objectives);
  builder_.add_flag_all_position(flag_all_position);
  builder_.add_henchman_members(henchman_members);
  builder_.add_hero_members(hero_members);
  builder_.add_player_members(player_members);
  builder_.add_party_id(party_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Party> CreatePartyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t party_id = 0,
    const std::vector<flatbuffers::Offset<GWIPC::AgentLiving>> *player_members = nullptr,
    const std::vector<flatbuffers::Offset<GWIPC::Hero>> *hero_members = nullptr,
    const std::vector<flatbuffers::Offset<GWIPC::AgentLiving>> *henchman_members = nullptr,
    const GWIPC::Vec3 *flag_all_position = nullptr,
    const std::vector<flatbuffers::Offset<GWIPC::MissionObjective>> *mission_objectives = nullptr) {
  auto player_members__ = player_members ? _fbb.CreateVector<flatbuffers::Offset<GWIPC::AgentLiving>>(*player_members) : 0;
  auto hero_members__ = hero_members ? _fbb.CreateVector<flatbuffers::Offset<GWIPC::Hero>>(*hero_members) : 0;
  auto henchman_members__ = henchman_members ? _fbb.CreateVector<flatbuffers::Offset<GWIPC::AgentLiving>>(*henchman_members) : 0;
  auto mission_objectives__ = mission_objectives ? _fbb.CreateVector<flatbuffers::Offset<GWIPC::MissionObjective>>(*mission_objectives) : 0;
  return GWIPC::CreateParty(
      _fbb,
      party_id,
      player_members__,
      hero_members__,
      henchman_members__,
      flag_all_position,
      mission_objectives__);
}

struct Instance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCE_ID = 4,
    VT_MAP_ID = 6
  };
  uint32_t instance_id() const {
    return GetField<uint32_t>(VT_INSTANCE_ID, 0);
  }
  uint32_t map_id() const {
    return GetField<uint32_t>(VT_MAP_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INSTANCE_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAP_ID, 4) &&
           verifier.EndTable();
  }
};

struct InstanceBuilder {
  typedef Instance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance_id(uint32_t instance_id) {
    fbb_.AddElement<uint32_t>(Instance::VT_INSTANCE_ID, instance_id, 0);
  }
  void add_map_id(uint32_t map_id) {
    fbb_.AddElement<uint32_t>(Instance::VT_MAP_ID, map_id, 0);
  }
  explicit InstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Instance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Instance>(end);
    return o;
  }
};

inline flatbuffers::Offset<Instance> CreateInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t instance_id = 0,
    uint32_t map_id = 0) {
  InstanceBuilder builder_(_fbb);
  builder_.add_map_id(map_id);
  builder_.add_instance_id(instance_id);
  return builder_.Finish();
}

struct ClientData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER = 4,
    VT_INSTANCE = 6,
    VT_PARTY = 8,
    VT_GAME_STATE = 10
  };
  const GWIPC::Character *character() const {
    return GetPointer<const GWIPC::Character *>(VT_CHARACTER);
  }
  const GWIPC::Instance *instance() const {
    return GetPointer<const GWIPC::Instance *>(VT_INSTANCE);
  }
  const GWIPC::Party *party() const {
    return GetPointer<const GWIPC::Party *>(VT_PARTY);
  }
  GWIPC::GameState game_state() const {
    return static_cast<GWIPC::GameState>(GetField<int8_t>(VT_GAME_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHARACTER) &&
           verifier.VerifyTable(character()) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           VerifyOffset(verifier, VT_PARTY) &&
           verifier.VerifyTable(party()) &&
           VerifyField<int8_t>(verifier, VT_GAME_STATE, 1) &&
           verifier.EndTable();
  }
};

struct ClientDataBuilder {
  typedef ClientData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character(flatbuffers::Offset<GWIPC::Character> character) {
    fbb_.AddOffset(ClientData::VT_CHARACTER, character);
  }
  void add_instance(flatbuffers::Offset<GWIPC::Instance> instance) {
    fbb_.AddOffset(ClientData::VT_INSTANCE, instance);
  }
  void add_party(flatbuffers::Offset<GWIPC::Party> party) {
    fbb_.AddOffset(ClientData::VT_PARTY, party);
  }
  void add_game_state(GWIPC::GameState game_state) {
    fbb_.AddElement<int8_t>(ClientData::VT_GAME_STATE, static_cast<int8_t>(game_state), 0);
  }
  explicit ClientDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClientData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientData> CreateClientData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GWIPC::Character> character = 0,
    flatbuffers::Offset<GWIPC::Instance> instance = 0,
    flatbuffers::Offset<GWIPC::Party> party = 0,
    GWIPC::GameState game_state = GWIPC::GameState_Unknown) {
  ClientDataBuilder builder_(_fbb);
  builder_.add_party(party);
  builder_.add_instance(instance);
  builder_.add_character(character);
  builder_.add_game_state(game_state);
  return builder_.Finish();
}

inline const GWIPC::ClientData *GetClientData(const void *buf) {
  return flatbuffers::GetRoot<GWIPC::ClientData>(buf);
}

inline const GWIPC::ClientData *GetSizePrefixedClientData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<GWIPC::ClientData>(buf);
}

inline bool VerifyClientDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GWIPC::ClientData>(nullptr);
}

inline bool VerifySizePrefixedClientDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GWIPC::ClientData>(nullptr);
}

inline void FinishClientDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GWIPC::ClientData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedClientDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GWIPC::ClientData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace GWIPC

#endif  // FLATBUFFERS_GENERATED_CLIENTDATA_GWIPC_H_
